# Documented Design

<br>

Top Down Design
---


<br>

Program Flow Diagram
---


<br>

User Interface Design
---
I believe that development of an application should always start at the user level, what does the user want the program to do and how does the user want to interact with it. For this reason, the first thing that I started designing for my app was the UI. Below is a layout that I think fulfills Gary's success criteria (dark mode, no submenus and everything labeled).  
There are three text inputs at the top to enter your username and password when opening a remote shell and to define the network range for the scan. There is a start scan button which will change colour when a scan is in progress, and a settings button to configure what type of scan you would like to run. Lastly there is also a dropdown for the network profile so that the known device can be saved for each network that Gary is on.  
The devices are all saved to a certain network profile, which can be updated with the save button. The filter button next to it is used to filter the shown devices, and when a device is clicked, the details are loaded into the larger display to the left.

![Initial UI Design](./images/docdesign_ui.png)

<br>

Data Flow Diagram
---


<br>

Algorithm Design
---


<br>

OOP Design
---
My project definitely calls for OOP as the scanning tool effectively models the network. Below is a UML diagram to visualise my objects and their relationships.  
The network profile is made up of device objects and a user object **(composition)**. Gary will be able to select which network profile is used, and therefore what devices are already known and the scan settings.  
The device class has two child classes **(inheritance/generalisation)** which inherit its attributes and methods. These also have scanning operations/methods, and the ping method is overridden the the Unknown Device child class **(overiding polymorphism)**. This is so that the known devices can have a quick TCP SYN Scan connection on a known open port, instead of a standard ICMP ping which all other devices would recieve. If the device does not respond to the port ping, then the scan falls back to ICMP to check if the service has stopped, or if the device is offline. 

![UML Class Diagram](./images/docdesign_oop.png)

<br>

Database Design
---


<br>

IPSO Chart
---
